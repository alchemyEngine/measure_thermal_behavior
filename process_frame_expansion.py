import json
import logging
from rich.logging import RichHandler

import pandas as pd
from numpy import polyfit, polyval
from matplotlib import pyplot as plt
from pathlib import Path

logging.basicConfig(level=logging.INFO, 
                    format="%(message)s",
                    datefmt="[%X]",
                    handlers=[RichHandler()])
logger = logging.getLogger(__name__)


class ThermalProfile():
    NON_TEMP_COLS = ['datetime', 'mcu_z', 'sample_index', 'elapsed_min']

    def __init__(self, json_results_path: str) -> None:
        self._json_results = self.import_json_results(json_results_path)
        self._expansion_thermals = self.temperature_to_pd(self._json_results)
        self._json_path = json_results_path

    def import_json_results(self, path: str) -> dict:
        logger.info('Reading results JSON file: "%s"', path)
        with open(path, 'r') as result_file:
            results = json.load(result_file)
        if results['metadata']['script']['data_structure'] < 3:
            err_msg = 'Dataset generated by incompatible measurement script.\n'\
            'Please rerun the thermal profiling measuring script.'
            raise ValueError(err_msg)
        return results

    def temperature_to_pd(self, results: dict) -> pd.DataFrame:
        'Organize JSON temperature results into a pandas dataframe'
        df_temperatures_raw = (pd.DataFrame(results['temp_data'])
            .reset_index()
            .rename(columns={'index': 'measurement'})
            .melt(
                id_vars='measurement',
                var_name='datetime')
            .pivot(
                index='datetime',
                columns='measurement',
                values='value')
            .reset_index()
        )
        df_temperatures_raw.datetime = pd.to_datetime(df_temperatures_raw.datetime, 
                                                    format="%Y/%m/%d-%H:%M:%S")

        df_temperatures_raw['elapsed_min'] = (df_temperatures_raw.datetime
                                            .diff()
                                            .dt
                                            .total_seconds()\
                                            .cumsum().fillna(0)
                                            .div(60)
        )

        return df_temperatures_raw

    def export_to_csv(self, path: Path, filename: str = None) -> None:
        if not filename:
            timestamp = self.user_data['timestamp']
            username = self.user_data['id']
            filename = f'thermal_profile_raw_{username}_{timestamp}.csv'

        out_path = path/filename
        logging.info('Exported thermal profile CSV to:\n"%s"', out_path.absolute())
        self._expansion_thermals.to_csv(out_path, index = False)

    def _get_temp_columns(self):
        raw = self._expansion_thermals
        raw_temps = raw.loc[ : ,~raw.columns.isin(self.NON_TEMP_COLS)]
        raw_temps = raw_temps.loc[: , [col for col in raw_temps.columns if '_target' not in col]]
        raw_temps = raw_temps.loc[:,
                                  ([(raw_temps[col] != -180.)
                                    .all() for col in raw_temps.columns])
                                  ]
        return raw_temps.columns

    def export_metadata_to_txt(self, path: Path, filename: str = None,) -> None:
        if not filename:
            timestamp = self.user_data['timestamp']
            username = self.user_data['id']
            filename = f'metadata_{username}_{timestamp}'
        out_path = path/f"{filename}.txt"
        with open(out_path, 'w') as outfile:
            json.dump(self.metadata, outfile, indent=4)
        logging.info('Exported thermal profile metadata to:\n"%s"',
                     out_path.absolute())
        
        
    @property
    def z_axis(self) -> dict:
        'Z-axis configuration metadata.'
        return self._json_results['metadata']['z_axis']
    
    @property
    def raw_expansion_thermals(self) -> pd.DataFrame:
        'Unmodified Pandas dataframe object'
        return self._expansion_thermals
    
    @property
    def json_results(self) -> dict:
        return self._json_results

    @property
    def metadata(self) -> dict:
        return self._json_results['metadata']

    @property
    def user_data(self) -> dict:
        return self._json_results['metadata']['user']

    @property
    def timestamp(self) -> str:
        return self._json_results['metadata']['user']['timestamp']

    @property
    def user_id(self) -> str:
        id = str(self._json_results['metadata']['user']['id']).replace('#', '')
        return id if id else 'unknown_user'

    @property
    def results_filename(self) -> str:
        return self._json_path.strip('\\').strip('\\.').replace('.json', '')

    @property
    def temp_sensors(self) -> list:
        return list(self._get_temp_columns())


class ThermalAnalysis():
    def __init__(self, profile: ThermalProfile) -> None:
        self.raw_thermals = profile.raw_expansion_thermals
        self.profile = profile
        self._json_results = profile.json_results
        
        # Calculate the mean and standard deviation of samples
        self.mean_thermals = (self.raw_thermals
            .groupby(['sample_index'])
            .mean(numeric_only=False)
            .join((self.raw_thermals.groupby(['sample_index'])
                .std()),
                    on='sample_index', lsuffix='_mean', rsuffix='_sd')
        )

        self.mean_thermals['delta_z_mean'] = (
            self.mean_thermals['mcu_z_mean']
                .transform(lambda x: (x-x.iloc[0]) * 
                           self._json_results['metadata']['z_axis']['step_dist'])
        )
        self.mean_thermals['delta_z_sd'] = (
            self.mean_thermals['mcu_z_sd'] * 
                self._json_results['metadata']['z_axis']['step_dist']
        )

        self.mean_thermals = (self.mean_thermals
            .drop(columns='elapsed_min_sd')
            .rename(columns={'elapsed_min_mean': 'elapsed_min'})
        )

        self._time_range = (15, max(self.mean_thermals['elapsed_min']))

        self.filtered_thermals, self._m = self.fit_temp_coeff(
            self.mean_thermals,
            self._time_range)

    def fit_temp_coeff(self, expansion_df: pd.DataFrame, 
                          elapsed_time_range: tuple = None) -> tuple:
        df = expansion_df

        logger.info('Fitting temp_coeff..')
        # Subset the dataset by elapsed time if provided
        if elapsed_time_range:
            logger.info('Using data points in time range: %.0f-%.0f min.',
                        self._time_range[0], self._time_range[1])
            df = (
                df.loc[df.elapsed_min >= min(elapsed_time_range)]
                .loc[df.elapsed_min <= max(elapsed_time_range)]
            )

        if any(df['frame_temp_mean'] == -180.):
            logger.warning(('No frame temperature data collected. Cannot'
                           ' calculate [bold italic]temp_coeff[/]'),
                           extra={"markup": True})
            return df, None

        # Linear fitting, store slope (m) and Y-intercept(c)
        m, c = polyfit(
            df['frame_temp_mean'],
            df['delta_z_mean'],
            1
        )

        # Create column of fitted Z values (for plotting)
        df['fit_delta_z'] = (
            polyval([m, c], 
                    df['frame_temp_mean'])
        )
        logger.info(('Calculated '
                     '[bold italic]temp_coeff[/] = '
                     f'{(m * -1): .6f} mm/degC'), extra={"markup": True})
        return df, m

    @property
    def mean_expansion_thermals(self) -> pd.DataFrame:
        return self.mean_thermals

    @property
    def temp_coeff(self) -> float:
        if self._m:
            return -1*self._m
        return None
    
    @property
    def raw_profile(self) -> ThermalProfile:
        return self.profile

class Plotter():
    def __init__(self, profile: ThermalAnalysis) -> None:
        self._thermal_analysis = profile

    def plot_timeseries(self, exclude_sensors=['he_temp', 'bed_temp']):
        df = self._thermal_analysis.mean_thermals
        user_data = self._thermal_analysis.raw_profile.user_data

        fig, host = plt.subplots(figsize=(8, 5), dpi=300)
        par1 = host.twinx()

        host.set_xlabel("Elapsed Time [min]")
        host.set_ylabel("Delta Z (+/- S.D.) [mm]")
        par1.set_ylabel("Temperature [degC]")

        colour1 = "black"
        host.plot(df['elapsed_min'], df['delta_z_mean'],
                        label='Delta Z', color=colour1,
                        zorder=4)
        host.errorbar(df['elapsed_min'],
                        df['delta_z_mean'],
                        yerr=df['delta_z_sd'],
                        color='grey',
                        marker=" ",
                        #   fmt=".k",
                        #  ecolor='frame_temp',
                        )
        for sensor in self._thermal_analysis.raw_profile._get_temp_columns():
            if sensor not in exclude_sensors:
                par1.plot(df['elapsed_min'], df[sensor+'_mean'],
                            label=sensor)

        par1.legend(title='Temperature Sensors', bbox_to_anchor=(1.1,0.5), loc=2)
        host.set_title(f"Frame Expansion Timeseries\n{user_data['id']} ({user_data['timestamp']})")
        fig.set_facecolor('white')
        fig.set_tight_layout(tight=True)
        return plt

    def plot_coeff_fitting(self, df: pd.DataFrame = None, temp_coeff: float = None):
        if not df:
            df = self._thermal_analysis.filtered_thermals
            if self._thermal_analysis.temp_coeff:
                fit = self._thermal_analysis.temp_coeff * -1
            else:
                logger.error('Cannot plot temp_coeff without frame_temp data')
                return None

        plt.figure(1, (6, 6), dpi=300)
        plt.scatter('delta_z_mean', 'frame_temp_mean', c='frame_temp_mean',
                    cmap='inferno', data=df,
                    zorder=4,
                    edgecolors="black",
                    alpha=0.8)
        plt.errorbar('delta_z_mean',
                     'frame_temp_mean',
                     xerr=df['delta_z_sd'],
                     fmt=".k",
                     #  ecolor='frame_temp',
                     marker=None,
                     data=df,
                     alpha=0.8)
        plt.axline((df['fit_delta_z'].min(),
                    df['frame_temp_mean'].max()
                    ),
                   slope=1/fit,
                   linestyle="--",
                    c='black')
        plt.title('%s\nFrame Expansion\nAll Measurement Data Points w/Fit' %
                    self._thermal_analysis.raw_profile.user_data['id'])
        plt.xlabel('Delta Z (Mean ± S.D.) [mm] ')
        plt.ylabel('Frame Temperature [degC]')
        plt.annotate(text="temp_coeff:\n%.4f mm/K" %
                        (-1*fit), xy=(0.7, 0.8), xycoords='figure fraction')
        return plt

    def save_all_plots(self, dir: Path):
        plt.close()
        self.plot_coeff_fitting().savefig(dir/'coeff_fit_plot.png')
        plt.close()
        self.plot_timeseries().savefig(dir/'timeseries.png')
        plt.close()
        logger.info('All plots saved to:\n"%s"', dir.absolute())

if __name__ == "__main__":
    from sys import argv
    from os import makedirs

    arg = argv[1]
    dataset_name = Path(arg.strip('.\\')).with_suffix('')
    logger.info('Analyzing file: "%s"', dataset_name)

    profile = ThermalProfile(arg)
    analysis = ThermalAnalysis(profile)
    plotter = Plotter(analysis)
    
    output_path = Path(profile.user_id, profile.timestamp)
    output_path.mkdir(parents=True, exist_ok=True)
    profile.export_to_csv(output_path)
    profile.export_metadata_to_txt(output_path, 'metadata')
    plotter.save_all_plots(output_path)
